"""
Asset Loader for Pipeline Inputs.

Loads assets from various sources:
  - Inline items in the pipeline YAML
  - External CSV files
  - External JSON files
  - External YAML files
  - External JSONL files (one JSON object per line)
  - Text files (one item per line for simple types)

Each asset gets a unique ID and is validated against the pipeline's type definition.
"""

import csv
import json
from pathlib import Path
from typing import Any

import yaml

from .spec_parser import AssetSpec, PipelineSpec, TypeDef


class AssetLoadError(Exception):
    """Error loading assets."""
    pass


def load_assets(spec: PipelineSpec, base_path: Path) -> list[dict[str, Any]]:
    """
    Load assets from the pipeline specification.
    
    Args:
        spec: The parsed pipeline specification
        base_path: Base path for resolving relative file paths
        
    Returns:
        List of asset dictionaries
        
    Raises:
        AssetLoadError: If assets cannot be loaded
    """
    if not spec.assets:
        return []
    
    assets = spec.assets
    
    # Load from external file if specified
    if assets.from_file:
        file_path = base_path / assets.from_file
        items = load_from_file(file_path)
    elif assets.items:
        items = assets.items
    elif assets.count:
        # Generate placeholder assets
        items = [{"id": f"item-{i+1:03d}"} for i in range(assets.count)]
    elif assets.generated_by:
        # Assets will be generated by a pipeline step
        return []
    else:
        return []
    
    # Validate and normalize assets
    type_def = spec.types.get(assets.type) if assets.type else None
    normalized = []
    
    for i, item in enumerate(items):
        # Ensure each asset has an ID
        if "id" not in item:
            item["id"] = f"item-{i+1:03d}"
        
        # Validate against type definition if available
        if type_def:
            item = validate_asset(item, type_def)
        
        normalized.append(item)
    
    return normalized


def load_from_file(file_path: Path) -> list[dict[str, Any]]:
    """
    Load items from an external file.
    
    Supported formats:
      - CSV: First row is headers, subsequent rows are data
      - JSON: Array of objects
      - YAML: List of items
      - JSONL: One JSON object per line
      - TXT: One item per line (becomes {id: "item-N", content: "line"})
    
    Args:
        file_path: Path to the file
        
    Returns:
        List of item dictionaries
        
    Raises:
        AssetLoadError: If file cannot be loaded
    """
    if not file_path.exists():
        raise AssetLoadError(f"Asset file not found: {file_path}")
    
    suffix = file_path.suffix.lower()
    
    if suffix == ".csv":
        return load_csv(file_path)
    elif suffix == ".json":
        return load_json(file_path)
    elif suffix in (".yaml", ".yml"):
        return load_yaml(file_path)
    elif suffix == ".jsonl":
        return load_jsonl(file_path)
    elif suffix == ".txt":
        return load_txt(file_path)
    else:
        raise AssetLoadError(f"Unsupported file format: {suffix}")


def load_csv(file_path: Path) -> list[dict[str, Any]]:
    """Load items from a CSV file."""
    items = []
    
    with open(file_path, "r", newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            # Convert empty strings to None
            item = {k: (v if v else None) for k, v in row.items()}
            items.append(item)
    
    return items


def load_json(file_path: Path) -> list[dict[str, Any]]:
    """Load items from a JSON file."""
    with open(file_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    
    if not isinstance(data, list):
        raise AssetLoadError(f"JSON file must contain an array: {file_path}")
    
    return data


def load_yaml(file_path: Path) -> list[dict[str, Any]]:
    """Load items from a YAML file."""
    with open(file_path, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f)
    
    if not isinstance(data, list):
        raise AssetLoadError(f"YAML file must contain a list: {file_path}")
    
    return data


def load_jsonl(file_path: Path) -> list[dict[str, Any]]:
    """Load items from a JSONL file (one JSON object per line)."""
    items = []
    
    with open(file_path, "r", encoding="utf-8") as f:
        for i, line in enumerate(f, 1):
            line = line.strip()
            if not line:
                continue
            try:
                items.append(json.loads(line))
            except json.JSONDecodeError as e:
                raise AssetLoadError(f"Invalid JSON at line {i} in {file_path}: {e}")
    
    return items


def load_txt(file_path: Path) -> list[dict[str, Any]]:
    """Load items from a text file (one per line)."""
    items = []
    
    with open(file_path, "r", encoding="utf-8") as f:
        for i, line in enumerate(f, 1):
            line = line.strip()
            if not line:
                continue
            items.append({
                "id": f"item-{i:03d}",
                "content": line,
            })
    
    return items


def validate_asset(item: dict[str, Any], type_def: TypeDef) -> dict[str, Any]:
    """
    Validate an asset against its type definition.
    
    Ensures required fields are present and types are correct.
    
    Args:
        item: The asset data
        type_def: The type definition to validate against
        
    Returns:
        The validated (potentially modified) item
        
    Raises:
        AssetLoadError: If validation fails
    """
    validated = dict(item)
    
    for field_name, field_type in type_def.fields.items():
        value = validated.get(field_name)
        
        # Check required fields
        if value is None and not field_type.optional:
            # For image fields, they'll be generated - don't require them
            if field_type.base == "image":
                continue
            # For other fields, warn but continue (they might be generated)
            # In strict mode, we could raise here
        
        # Validate enum values
        if value is not None and field_type.enum_values:
            if value not in field_type.enum_values:
                raise AssetLoadError(
                    f"Invalid value '{value}' for field '{field_name}'. "
                    f"Must be one of: {', '.join(field_type.enum_values)}"
                )
        
        # Type coercion
        if value is not None:
            if field_type.base == "number":
                try:
                    validated[field_name] = float(value) if '.' in str(value) else int(value)
                except ValueError:
                    raise AssetLoadError(f"Field '{field_name}' must be a number, got: {value}")
            
            elif field_type.base == "boolean":
                if isinstance(value, str):
                    validated[field_name] = value.lower() in ("true", "yes", "1")
                else:
                    validated[field_name] = bool(value)
    
    return validated


def get_asset_by_id(assets: list[dict[str, Any]], asset_id: str) -> dict[str, Any] | None:
    """
    Find an asset by its ID.
    
    Args:
        assets: List of assets
        asset_id: ID to find
        
    Returns:
        The asset dict or None if not found
    """
    for asset in assets:
        if asset.get("id") == asset_id:
            return asset
    return None
