# Pipeline Specification Format

## Overview

ArtGen pipelines are defined in YAML files (`.artgen.yaml` or `pipeline.yaml`). The format is designed to be:

- **Human-readable** - Creative documents that explain the vision
- **Flexible** - Express any DAG of steps
- **Powerful** - Conditionals, loops, gather operations
- **Composable** - Reuse definitions via YAML anchors
- **Type-safe** - Define data classes for structured assets

---

## Top-Level Structure

```yaml
# Pipeline metadata
name: "Project Name"
version: "1.0"
description: |
  Multi-line description of what this pipeline produces.
  Explain the creative vision here.

# Define data types (like dataclasses)
types:
  # Type definitions...

# What we're producing
assets:
  # Asset definitions referencing types...

# Global context available to all steps
context:
  # Key-value pairs...

# The pipeline steps
steps:
  # Step definitions...
```

---

## Types Section

Define structured data types that your pipeline produces. Types are simple and readable.

### Basic Syntax

```yaml
types:
  TypeName:
    field_name: field_type
    another_field: another_type
```

### Field Types

| Syntax | Meaning | Example |
|--------|---------|---------|
| `text` | String content | `name: text` |
| `image` | Generated image | `art: image` |
| `number` | Numeric value | `cost: number` |
| `boolean` | True/false | `approved: boolean` |
| `a \| b \| c` | One of these values (enum) | `rarity: common \| rare \| mythic` |
| `list` | List of items | `colors: list` |
| `Type?` | Optional (can be null) | `flavor: text?` |
| `OtherType` | Reference another type | `weapon: Item` |

### Simple Example: Game Sprite

```yaml
types:
  GameSprite:
    name: text
    unit_class: infantry | cavalry | ranged | magic
    prompt: text
    sprite: image
```

### Complex Example: Magic Card

```yaml
types:
  MagicCard:
    # Identity
    name: text
    id: text
    
    # Game mechanics  
    mana_cost: text
    colors: list                            # List of colors
    type_line: text                         # "Creature - Elf Warrior"
    abilities: text
    power: number?                          # Optional - only for creatures
    toughness: number?
    
    # Creative content
    flavor_text: text?                      # Optional
    art_prompt: text
    art: image
    
    # Metadata
    rarity: common | uncommon | rare | mythic
    set_number: number
```

### Reusing Field Definitions (YAML Anchors)

Use native YAML anchors to share common fields:

```yaml
types:
  # Define common fields once
  _base_card: &base_card
    name: text
    id: text
    art: image
    rarity: common | uncommon | rare | mythic

  CreatureCard:
    <<: *base_card          # Include base fields
    power: number
    toughness: number
    creature_type: text

  SpellCard:
    <<: *base_card          # Same base fields
    effect: text
    instant: boolean
```

### Nested Structures

For complex nested data, define multiple types:

```yaml
types:
  Stats:
    health: number
    mana: number  
    strength: number
    
  Item:
    name: text
    icon: image
    slot: weapon | armor | accessory

  Character:
    name: text
    portrait: image
    stats: Stats            # Reference Stats type
    equipment: list         # List of Items
```

---

## Assets Section

Define what you're producing by referencing your types.

### Simple Assets (built-in image type)

```yaml
assets:
  type: image
  count: 10
```

Or provide an explicit list:

```yaml
assets:
  type: image
  items:
    - id: archer
      prompt: "Pixel art archer unit"
    - id: knight  
      prompt: "Pixel art knight unit"
```

### Typed Assets

Reference a type you defined:

```yaml
types:
  GameSprite:
    name: text
    unit_class: infantry | cavalry | ranged | magic
    sprite: image

assets:
  type: GameSprite
  items:
    - id: archer
      name: "Elven Archer"
      unit_class: ranged
      # sprite will be generated by pipeline
    - id: knight
      name: "Royal Knight"  
      unit_class: cavalry
```

### Dynamic Asset Generation

Assets can be created by a pipeline step:

```yaml
types:
  MagicCard:
    name: text
    rarity: common | uncommon | rare | mythic
    art: image

assets:
  type: MagicCard
  generated_by: design_card_list  # Step creates the list

steps:
  - id: design_card_list
    type: generate_text
    config:
      prompt: "Design 50 cards for a fantasy set..."
      output_type: MagicCard  # AI outputs structured data
```

### External Input File

Load assets from a separate file instead of defining inline. This is useful when:
- You want to reuse a pipeline with different input lists
- Your asset list is large and maintained separately
- Input comes from another system (spreadsheet, database export)

```yaml
types:
  GameSprite:
    name: text
    unit_class: infantry | cavalry | ranged | magic
    prompt: text
    sprite: image?

assets:
  type: GameSprite
  from_file: ./units.csv    # Load from external file
```

Supported file formats:

| Format | Extension | Notes |
|--------|-----------|-------|
| CSV | `.csv` | First row is headers, maps to field names |
| JSON | `.json` | Array of objects |
| YAML | `.yaml`, `.yml` | List of items |
| JSONL | `.jsonl` | One JSON object per line |
| Text | `.txt` | One item per line (for simple types) |

**CSV Example** (`units.csv`):
```csv
id,name,unit_class,prompt
archer,Elven Archer,ranged,Archer unit with bow
knight,Royal Knight,infantry,Knight with sword and shield
wizard,Battle Mage,magic,Wizard casting spell
```

**JSON Example** (`units.json`):
```json
[
  {"id": "archer", "name": "Elven Archer", "unit_class": "ranged", "prompt": "Archer with bow"},
  {"id": "knight", "name": "Royal Knight", "unit_class": "infantry", "prompt": "Knight with shield"}
]
```

**CLI Override**: You can also specify the input file at runtime:
```bash
artgen run pipeline.yaml --input ./new-units.csv
```

### Partial Data

Provide known fields, let pipeline generate the rest:

```yaml
assets:
  type: MagicCard
  items:
    - id: card-001
      name: "Eternal Guardian"      # Known
      rarity: mythic                # Known
      # art, abilities generated by pipeline
```

---

## Context Section

Global values available to all steps. Can include style guides, reference text, configuration.

```yaml
context:
  style: "16-bit pixel art, limited palette, clean edges"
  palette: ["#1a1c2c", "#5d275d", "#b13e53", "#ef7d57"]
  art_direction: |
    We're creating sprites for a tactical RPG.
    Characters should be recognizable at 64x64.
    Use strong silhouettes and limited colors.
```

Context values are accessible in prompts via `{context.style}` or `{ctx.palette}`.

---

## State & Checkpoints

Pipelines save state to enable:
- **Resume** - Continue after interruption without redoing work
- **Incremental runs** - Add new assets without re-running global steps
- **Caching** - Skip expensive steps if output already exists

### State Directory

By default, state is saved to `.artgen/` in the pipeline directory:

```yaml
state:
  directory: .artgen/           # Default location
```

Or specify a custom location:

```yaml
state:
  directory: ./my-project-state/
```

### Step Outputs

Each step can specify where its output is saved:

```yaml
steps:
  # Global step - saves to single file
  - id: research_style
    type: research
    save_to: research/style_guide.json
    cache: true                 # Skip if file exists and is valid
    config:
      query: "Pixel art styles for tactical RPGs"

  # Per-asset step - saves to folder with one file per asset
  - id: generate_sprite
    type: generate_sprite
    for_each: asset
    save_to: sprites/{asset.id}/      # Folder per asset
    config:
      prompt: "{context.style}, {asset.prompt}"
      variations: 3
```

### Save Locations

| Pattern | Expands To | Use Case |
|---------|------------|----------|
| `research/style.json` | `.artgen/research/style.json` | Global step output |
| `sprites/{asset.id}/` | `.artgen/sprites/archer/`, etc. | Per-asset folder |
| `cards/{asset.id}.png` | `.artgen/cards/archer.png` | Per-asset file |
| `outputs/{step.id}/{asset.id}_v{variation}.png` | Versioned outputs | Multiple variations |

### Caching Behavior

```yaml
steps:
  - id: expensive_research
    type: research
    save_to: research/themes.json
    cache: true                 # If file exists, load it instead of running
    
  - id: generate_art
    type: generate_image
    for_each: asset
    save_to: art/{asset.id}/
    cache: skip_existing        # Only process assets without existing output
```

Cache options:
- `true` - Load from file if exists, skip step entirely
- `false` - Always run (default)
- `skip_existing` - For per-asset steps, only process assets without saved output

### Incremental Workflow Example

**First run** - Research theme, generate 5 sprites:

```yaml
# pipeline.yaml
assets:
  type: GameSprite
  from_file: ./batch1.csv       # 5 units

steps:
  - id: research_style
    type: research
    save_to: research/style.json
    cache: true                 # Expensive - cache it
    
  - id: generate
    type: generate_sprite
    for_each: asset
    save_to: sprites/{asset.id}/
```

```bash
artgen run pipeline.yaml
# Creates: .artgen/research/style.json
# Creates: .artgen/sprites/archer/, .artgen/sprites/knight/, ...
```

**Second run** - Generate 5 more sprites using same theme:

```bash
artgen run pipeline.yaml --input ./batch2.csv
# Loads: .artgen/research/style.json (cached, not re-run)
# Creates: .artgen/sprites/wizard/, .artgen/sprites/healer/, ...
```

### State Files

The state directory contains:

```
.artgen/
├── pipeline.lock              # Pipeline definition hash (detect changes)
├── progress.jsonl             # Asset progress tracking
├── context.json               # Resolved context values
├── research/
│   └── style.json             # Cached research output
└── sprites/
    ├── archer/
    │   ├── meta.json          # Step metadata, timestamps
    │   ├── sprite_v1.png
    │   ├── sprite_v2.png
    │   └── sprite_v3.png
    └── knight/
        └── ...
```

### Clearing Cache

```bash
# Clear all state (full re-run)
artgen clean pipeline.yaml

# Clear specific step
artgen clean pipeline.yaml --step research_style

# Clear specific asset
artgen clean pipeline.yaml --asset archer
```

### Export Final Outputs

After generation, export deliverables to a clean folder:

```yaml
export:
  directory: ./final/           # Clean export location
  steps:
    - generate_sprite: sprites/{asset.id}/final.png
    - resize: sprites/{asset.id}/sizes/
```

Or via CLI:
```bash
artgen export pipeline.yaml --output ./deliverables/
```

---

## Steps Section

The heart of the pipeline. Each step has:

| Field | Required | Description |
|-------|----------|-------------|
| `id` | Yes | Unique identifier |
| `type` | Yes | Step type (see below) |
| `requires` | No | List of step IDs that must complete first |
| `for_each` | No | Run once per asset (`asset`) or per item in a list |
| `gather` | No | If true, wait for ALL parallel instances to complete |
| `condition` | No | Expression that must be true to run |
| `config` | No | Type-specific configuration |

### Step Types

| Type | Description | Key Config |
|------|-------------|------------|
| `research` | AI researches a topic | `query` |
| `generate_text` | Generate text content | `prompt`, `max_length` |
| `generate_name` | Generate a name | `style`, `constraints` |
| `generate_prompt` | Create an image prompt | `template`, `use` |
| `generate_image` | Generate images | `variations`, `size`, `model` |
| `generate_sprite` | Generate with transparency | `variations`, `size` |
| `assess` | AI evaluates quality | `criteria`, `threshold` |
| `user_select` | Human chooses best | `prompt`, `options_from` |
| `user_approve` | Human yes/no gate | `prompt` |
| `refine` | Improve based on feedback | `feedback_from`, `target` |
| `composite` | Combine multiple outputs | `layers`, `template` |
| `remove_background` | Make transparent | `method` |
| `resize` | Change dimensions | `sizes` |
| `loop` | Repeat until condition | `until`, `max_iterations`, `steps` |
| `branch` | Conditional paths | `on`, `paths` |
| `custom` | User-defined Python | `function`, `module` |

---

## Expression Language

Conditions and dynamic values use a simple expression language:

### Comparison
```yaml
condition: "rarity == 'legendary'"
condition: "quality >= 0.8"
condition: "iteration < 5"
```

### Logical
```yaml
condition: "rarity == 'rare' and quality < 0.7"
condition: "approved or iteration >= max_iterations"
```

### Ternary
```yaml
variations: "5 if rarity == 'legendary' else 2"
```

### Accessing Values
```yaml
# From context
prompt: "Create {context.style} art for {asset.name}"

# From previous step output
prompt: "Refine based on: {assess.feedback}"

# Asset fields
condition: "asset.rarity == 'legendary'"
```

---

## Complete Examples

### Example 1: Simple Sprite Generation

```yaml
name: "Game Unit Sprites"
description: |
  Generate pixel art sprites for a tactical RPG.
  Each unit needs a transparent sprite at multiple sizes.

context:
  style: "16-bit pixel art, clean edges, limited palette"
  sizes: [32, 64, 128]

assets:
  type: image
  items:
    - id: archer
      prompt: "Archer unit with bow"
    - id: knight
      prompt: "Knight with sword and shield"
    - id: wizard
      prompt: "Wizard with staff and robes"
    - id: healer
      prompt: "Healer with glowing hands"

steps:
  - id: generate
    type: generate_sprite
    for_each: asset
    config:
      prompt: "{context.style}, {asset.prompt}, game sprite"
      variations: 3
      size: 512

  - id: select_best
    type: user_select
    for_each: asset
    requires: [generate]
    config:
      prompt: "Choose the best sprite for {asset.id}"

  - id: export
    type: resize
    for_each: asset
    requires: [select_best]
    config:
      sizes: "{context.sizes}"
      format: png
```

### Example 2: Magic Card Set with Dynamic Mechanics

```yaml
name: "Shadows of Valdris"
version: "1.0"
description: |
  A 250-card Magic-style set with gothic horror themes.
  Includes new mechanics decided during generation.

context:
  setting: "Gothic horror, crumbling cathedrals, haunted forests"
  color_philosophy:
    white: "Corrupt church, false purity"
    black: "Vampires, necromancy"
    red: "Werewolves, rage"
    green: "Cursed nature, overgrowth"
    blue: "Forbidden knowledge, sea horrors"

assets:
  type: object
  schema:
    name: text
    mana_cost: text
    type_line: text
    abilities: text
    flavor_text: text
    art: image
    rarity: enum[common, uncommon, rare, mythic]
  generated_by: card_list  # Cards defined by earlier step

steps:
  # --- Phase 1: Set Design (runs once) ---
  
  - id: research_mtg
    type: research
    config:
      query: "Recent Magic: The Gathering set mechanics, gothic horror themes"

  - id: brainstorm_mechanics
    type: generate_text
    requires: [research_mtg]
    config:
      prompt: |
        Based on {research_mtg.output}, brainstorm 10 new keyword mechanics
        for a gothic horror Magic set. For each, provide:
        - Name
        - Rules text template
        - Flavor justification
        - Which colors it appears in
      variations: 3
  
  - id: select_mechanics
    type: user_select
    requires: [brainstorm_mechanics]
    config:
      prompt: "Choose 3-4 mechanics for the set"
      count: 4

  - id: card_list
    type: generate_text
    requires: [select_mechanics]
    config:
      prompt: |
        Generate a list of 250 cards for this set.
        Include the selected mechanics: {select_mechanics.output}
        Distribution: 100 common, 80 uncommon, 50 rare, 20 mythic
        Output as YAML with fields: id, name, rarity, colors, card_type
      output_format: yaml
      # This step DEFINES the assets for subsequent steps

  # --- Phase 2: Per-Card Generation (parallel) ---

  - id: generate_abilities
    type: generate_text
    for_each: asset
    requires: [card_list, select_mechanics]
    config:
      prompt: |
        Write abilities for {asset.name}, a {asset.rarity} {asset.card_type}.
        Use mechanics: {select_mechanics.output}
        Match power level to rarity.

  - id: generate_flavor
    type: generate_text
    for_each: asset
    requires: [generate_abilities]
    config:
      prompt: |
        Write flavor text for {asset.name}.
        Setting: {context.setting}
        Abilities context: {generate_abilities.output}
        Max 2 sentences. Evocative, not explanatory.

  - id: generate_art_prompt
    type: generate_prompt
    for_each: asset
    requires: [generate_flavor]
    config:
      template: |
        Magic: The Gathering card art, {context.setting}
        Card: {asset.name} - {asset.card_type}
        Scene that captures: {generate_flavor.output}
        Style: Painterly, dramatic lighting, dark fantasy

  - id: generate_art
    type: generate_image
    for_each: asset
    requires: [generate_art_prompt]
    config:
      prompt: "{generate_art_prompt.output}"
      variations: "4 if asset.rarity in ['rare', 'mythic'] else 2"
      size: 1024

  - id: assess_art
    type: assess
    for_each: asset
    requires: [generate_art]
    config:
      criteria:
        - "Matches card concept and name"
        - "Fits gothic horror setting"
        - "Composition suitable for card frame"
        - "No text or watermarks"
      threshold: 0.75
      on_fail: retry
      max_retries: 2

  - id: art_approval
    type: user_approve
    for_each: asset
    requires: [assess_art]
    condition: "asset.rarity in ['rare', 'mythic']"
    config:
      prompt: "Approve art for {asset.name}?"

  # --- Phase 3: Assembly (gather) ---

  - id: compile_set
    type: custom
    gather: true
    requires: [art_approval, generate_abilities, generate_flavor]
    config:
      function: compile_card_set
      output_format: json
```

### Example 3: Iterative Refinement Loop

```yaml
name: "Hero Portrait"
description: "Generate a single high-quality character portrait with iterative refinement"

context:
  character: "Elara, a battle-scarred elven ranger"
  style: "Digital painting, detailed, dramatic lighting"

assets:
  type: image
  count: 1

steps:
  - id: initial_prompt
    type: generate_prompt
    config:
      template: |
        {context.style}
        Portrait of {context.character}
        Half-body shot, looking at viewer
        Forest background, dappled light

  - id: refinement
    type: loop
    requires: [initial_prompt]
    config:
      max_iterations: 5
      until: "approved == true"
      
      steps:
        - id: generate
          type: generate_image
          config:
            prompt: "{current_prompt}"
            variations: 3
            size: 1024

        - id: assess
          type: assess
          requires: [generate]
          config:
            criteria:
              - "Face is clear and expressive"
              - "Lighting matches forest setting"
              - "Battle scars visible but not grotesque"
              - "Elven features present"
            output: feedback

        - id: decide
          type: user_select
          requires: [assess]
          config:
            prompt: "Select best, or reject all to refine"
            options:
              - "Accept option 1"
              - "Accept option 2"
              - "Accept option 3"
              - "Reject all - refine further"
            output: choice

        - id: refine_prompt
          type: generate_text
          requires: [decide]
          condition: "choice == 'reject'"
          config:
            prompt: |
              Current prompt: {current_prompt}
              Feedback: {assess.feedback}
              
              Improve the prompt to address the feedback.
            output: current_prompt  # Updates for next iteration

  - id: final_export
    type: resize
    requires: [refinement]
    config:
      sizes: [512, 1024, 2048]
```

### Example 4: Research-Heavy Pipeline

```yaml
name: "Historical Battle Scenes"
description: |
  Generate historically accurate battle scene illustrations.
  Heavy emphasis on research before generation.

context:
  era: "Napoleonic Wars"
  battles:
    - name: "Waterloo"
      year: 1815
    - name: "Austerlitz"
      year: 1805
    - name: "Borodino"
      year: 1812

assets:
  type: object
  schema:
    battle_name: text
    research_notes: text
    scene_description: text
    art: image
  items: "{context.battles}"  # Expand from context

steps:
  # Research runs in parallel for each battle
  - id: research_battle
    type: research
    for_each: asset
    config:
      query: |
        {asset.name} battle {asset.year}:
        - Key moments and turning points
        - Uniforms and equipment of both sides
        - Terrain and weather
        - Notable commanders and units

  - id: research_art_style
    type: research
    config:
      query: "Napoleonic battle paintings, historical military art styles"

  # Synthesis requires ALL research to complete
  - id: style_guide
    type: generate_text
    gather: true
    requires: [research_battle, research_art_style]
    config:
      prompt: |
        Based on research into Napoleonic art:
        {research_art_style.output}
        
        Create a style guide for historically accurate battle scenes.
        Include: color palette, composition rules, level of detail.

  # Now generate each scene
  - id: scene_description
    type: generate_text
    for_each: asset
    requires: [style_guide, research_battle]
    config:
      prompt: |
        Using research: {research_battle.output}
        And style guide: {style_guide.output}
        
        Describe a dramatic scene from {asset.name}.
        Include: specific units, terrain, weather, action.

  - id: generate_art
    type: generate_image
    for_each: asset
    requires: [scene_description]
    config:
      prompt: "{scene_description.output}"
      variations: 4
      size: 1536
```

---

## YAML Features We Use

### Anchors for Reuse

```yaml
# Define once
definitions:
  base_style: &base_style
    palette: limited
    edges: clean
    
steps:
  - id: sprite_1
    type: generate_sprite
    config:
      <<: *base_style  # Merge in
      prompt: "Archer"
      
  - id: sprite_2
    type: generate_sprite
    config:
      <<: *base_style  # Reuse same style
      prompt: "Knight"
```

### Multi-line Strings

```yaml
description: |
  This is a multi-line description.
  It preserves newlines.
  
  Great for detailed prompts.

# Or folded (newlines become spaces):
prompt: >
  This is a long prompt that
  will be joined into one line
  with spaces between.
```

### Comments

```yaml
steps:
  # Phase 1: Research
  # We do this first to inform the style guide
  - id: research
    type: research
    config:
      query: "..."
      
  # TODO: Add assessment step here
  # - id: assess
```

---

## Validation Rules

1. **Unique IDs** - Each step must have a unique `id`
2. **Valid requires** - Referenced steps must exist
3. **No cycles** - DAG must be acyclic
4. **Type-specific config** - Each step type has required fields
5. **Expression syntax** - Conditions must be valid expressions
6. **Asset schema match** - Steps that write to assets must match schema

---

## File Conventions

| File | Purpose |
|------|---------|
| `artgen.yaml` | Main pipeline definition |
| `artgen.local.yaml` | Local overrides (gitignored) |
| `.artgen/` | State directory |
| `.artgen/progress.jsonl` | Asset progress tracking |
| `.artgen/context.json` | Resolved context values |
| `.artgen/outputs/` | Generated artifacts |

---

## CLI Usage

```bash
# Validate a pipeline file
artgen validate pipeline.yaml

# Run a pipeline
artgen run pipeline.yaml

# Run with local overrides
artgen run pipeline.yaml --config artgen.local.yaml

# Run specific step
artgen run pipeline.yaml --step generate_art

# Resume from last state
artgen resume pipeline.yaml

# Show pipeline DAG
artgen show pipeline.yaml --graph
```
